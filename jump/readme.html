<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html" />
    <title>dSFMT jump function</title>
    <style type="text/css">
      BODY {margin-left: 2%}
      BLOCKQUOTE {background-color:#e0ffe0;
                  padding-left: 1em;}
      div.math {padding-left:2em;}
    </style>
  </head>
  <body>
    <h2>dSFMT jump function</h2>

    <p>
      For a given integer N, this jump function executes the N-step
      jump. Namely, from the given state, obtain the state of dSFMT
      after N steps generation. This is equivalent to call the dSFMT
      32-bit integer generation 4N times with discarding the
      outputs. A typical usage of a jump function is to obtain
      distinct sub streams from a whole period of pseudorandom number
      sequence generated by one dSFMT.
    </p>
    <p>
      There are two steps for doing jump. Calculations of jump polynomial
      and changing internal state.
    </p>

    <h3>Calculations of jump polynomial</h3>
    <!--
    <p>From the characteristic polynomial <b>ϕ</b> of a linear random number
    generator and an integer <b>N</b>, we can get jump polynomial <b>ψ</b><p/>
      <div class="math">
      <b>ψ</b> = <b>X<sup>N</sup></b> mod <b>ϕ</b>.<br/>
      </div>
    <p>As a result, degree of jump polynomial <b>ψ</b> is less or equals to
      the characteristic polynomial <b>ϕ</b>, regardless of jump step N.
    </p>
    <p>dSFMT is Affine generator, we can't use this way as it is.
    </p>
    <p>
      If the characteristic polynomial of the F<sub>2</sub> linear
      part of an affine transition does not have the factor <b>x</b> -
      1, the affine transition has an fixed point. With an affine
      transition <b>f<sub>A</sub></b>, linear part of the
      transition <b>f<sub>L</sub></b>, internal state <b>s</b>, fixed
      point <b>p</b> and jump step <b>N</b>, we can calculate<p/>
      <div class="math">
      <b>f<sub>A</sub><sup>N</sup></b>(<b>s</b>)
      = <b>f<sub>L</sub><sup>N</sup></b>(<b>s</b> - <b>p</b>) + <b>p</b>.<br/>
      </div>
    <p>
      These cases are MEXP = 521, 1279, 4253 and 216091.
    </p>
    <p>
      Otherwise, we used super spaces of internal state spaces.
      We can regard the state transition function of dSFMT
      as an <b>F<sub>2</sub></b>-linear transition in super space.
      In this case, we don't need fixed point, but the jump polynomials
      will have larger degree than the former case, and as a result,
      jump will consume more time.
      These cases are MEXP = 2203, 11213, 19937, 44497, 86243 and 132049.
    </p>
    -->
    <p>To calculate jump polynomial, we use magic polynomials, that is
      polynomial version of magic number, for MEXPs. (We omit explanation of
      the polynomial.) These magic polynomial are stored in
      'magic.{MEXP}.txt files.<br/>
      The executable binary file 'calc-jump' calculates jump polynomial
      from command line. Here is a usage:
    </p>
      <blockquote>
	<pre>
./calc-jump jump-step magic-file
    jump-step: a number between zero and 2^{DSFMT_MEXP}-1.
               large decimal number is allowed.
    magic-file: one of magic.{MEXP}.txt file
</pre>
      </blockquote>
    <p>
      Users can call C++ function 'dsfmt::calc_jump' in C++ header file
      'dSFMT-calc-jump.hpp' to calculate jump polynomials.
      <br/>
      <a href="http://shoup.net/ntl/">NTL: A Library for doing Number
    Theory</a> by Victor Shoup is used for polynomial calculation and
    handling large integers.
      <br/>
      This step does not use dSFMT internal state and independent
      from MEXPs except file names of magic polynomials.
    </p>

    <h3>Changing internal state of dSFMT to jumped state.</h3>
<!--
    <p>Getting jumped state is an application of Cayley-Hamilton theorem.
      Let <b>A</b> be a representation matrix of linear function <b>f</b>.
    </p>
    <div class="math">
      When ψ(x)
      = &Sigma;<sub>i=0</sub><sup>n</sup>  a<sub>i</sub>x<sup>i</sup><br>
	<b>f<sup>N</sup>(s) = A<sup>N</sup>s<br/>
	  = (A<sup>N</sup> mod ϕ(A) )s<br/>
	  = (ψ(A))s<br/>
	  = &Sigma;<sub>i=0</sub><sup>n</sup> a<sub>i</sub>f<sup>i</sup>(s)</b>.
      </div>
	<p>
	  Remember we have f(s) written in C program and addition of
	  internal states can be calculated using exclusive or.
    </p>
-->
    <p>This step depends on MEXPs of dSFMT, and the magic
      polynomial of dSFMT should be the same as one used for the jump
      polynomial calculation.
      <br/>
      The function dSFMT-jump written in C language does this step.
    </p>

    <h3>Compile and test</h3>
    <p><a href="http://shoup.net/ntl/">NTL</a> is required for compile. If you
      installed NTL with gmp or gf2x, you will need to change Makefile.
    </p>
    <blockquote>
<pre>
make all
</pre>
    </blockquote>

    <p>test-jump-MXXX files made by above can invoke with '-s'
      argument like this:
    </p>
    <blockquote>
<pre>
$ ./test-jump-M19937 -s
mexp 19937 jump 10^04 steps  calc_jump: 0.707ms
mexp 19937 jump 10^04 steps dSFMT_jump: 0.166ms
mexp 19937 jump 10^06 steps  calc_jump: 3.527ms
mexp 19937 jump 10^06 steps dSFMT_jump: 3.657ms
mexp 19937 jump 10^08 steps  calc_jump: 6.310ms
mexp 19937 jump 10^08 steps dSFMT_jump: 3.628ms
mexp 19937 jump 10^10 steps  calc_jump: 9.221ms
mexp 19937 jump 10^10 steps dSFMT_jump: 3.579ms
mexp 19937 jump 10^12 steps  calc_jump:12.175ms
mexp 19937 jump 10^12 steps dSFMT_jump: 3.638ms
mexp 19937 jump 10^14 steps  calc_jump:15.176ms
mexp 19937 jump 10^14 steps dSFMT_jump: 3.630ms
mexp 19937 jump 10^16 steps  calc_jump:18.064ms
mexp 19937 jump 10^16 steps dSFMT_jump: 3.626ms
mexp 19937 jump 10^18 steps  calc_jump:20.959ms
mexp 19937 jump 10^18 steps dSFMT_jump: 3.606ms
mexp 19937 jump 10^20 steps  calc_jump:23.884ms
mexp 19937 jump 10^20 steps dSFMT_jump: 3.600ms
mexp 19937 jump 10^22 steps  calc_jump:26.920ms
mexp 19937 jump 10^22 steps dSFMT_jump: 3.592ms
</pre>
    </blockquote>

    <h3>Parallel generation sample</h3>
    <p>
    Getting distinct sub sequences is an important purpose of
    jump function, however jump function is also available to get
    a sub-sequence using parallel computing.
    </p>
    <p>
      Here is a sample of generating a sequence using 5 dSFMT instances:
      <a href="sample2.c">sample2.c</a>.<br/>
      <a href="sample1.c">sample1.c</a> shows more simple, far away
      sub-sequence generation.
    </p>

    <h3>License</h3>
    <p>
      dSFMT-jump, as well as dSFMT, can be used freely for any
      purpose, including commercial use.
      See <a href="LICENSE.txt">LICENSE.txt</a> for detail.
    </p>
  </body>
</html>
